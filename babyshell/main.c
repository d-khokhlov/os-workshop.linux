#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

#define BUFFER_SIZE 100

int main( int argc, char **argv )
{
    // Создать копии дескрипторов stdin (0) и stdout (1),
    // чтобы можно было восстановить их после.
    int inFd = dup( 0 );
    int outFd = dup( 1 );

    // Главный цикл
    while ( 1 ) {

        // Вывести приглашение
        printf( "%s", "> " );

        // Прочитать командную строку пользователя
        char input[ BUFFER_SIZE ] = "";
        fgets( input, BUFFER_SIZE, stdin );

        // Разбить введенную строку на отдельные команды, разделенные символом '|'
        char *commands[ BUFFER_SIZE ];
        commands[ 0 ] = strtok( input, "|" );
        int commandIndex = 0;
        while ( commands[ commandIndex ] != NULL ) {
            commandIndex++;
            commands[ commandIndex ] = strtok( NULL, "|" );
        }

        // Параметры команды (нулевой элемент - сама команда)
        char *parameters[ BUFFER_SIZE ];

        // Обработать каждую команду
        for ( commandIndex = 0; commands[ commandIndex ] != NULL; commandIndex++ ) {

            // Пробельные символы, которыми разделяются параметры
            char *spaces = " \t\n\r\v\f";

            // Выделить имя команды (исполняемого файла)
            parameters[ 0 ] = strtok( commands[ commandIndex ], spaces );

            // Если команда пустая, перейти к следующей
            if ( parameters[ 0 ] == NULL ) {
                continue;
            }

            // Если получена команда 'exit', выйти (со статусом успеха)
            if ( strcmp( parameters[ 0 ], "exit" ) == 0 ) {
                return 0;
            }

            // Дескрипторы канала для передачи ввода/вывода между командами
            int pipeFds[ 2 ];

            // Если текущая команда не последняя
            if ( commands[ commandIndex + 1 ] != NULL ) {

                // Создать канал для текущей и следующей команд
                pipe( pipeFds );

                // Закрыть stdout (дескриптор 1 становится свободным)
                close( 1 );

                // Создать копию дескриптора входа канала (write end).
                // В качестве копии береться минимальный свободный дескриптор
                // (в данном случае 1), таким образом stdout связывается с входом канала.
                dup( pipeFds[ 1 ] );

                // Закрыть первоначальный дескриптор входа канала.
                // Иначе канал не достигнет EOF.
                close( pipeFds[ 1 ] );

            // Если текущая команда последняя, но не единственная
            } else if ( commandIndex > 0 ) {

                // Восстановить оригинальный stdout
                close( 1 );
                dup( outFd );
            }

            // Имена файлов для перенаправления ввода/вывода.
            // NULL означает, что соответствующего перенаправления нет.
            char *inputFilename = NULL;
            char *outputFilename = NULL;

            // Индекс элемента массива для сохранения следующего параметра команды
            int parameterIndex = 1;

            // Извлечь параметры команды по одному
            while( ( parameters[ parameterIndex ] = strtok( NULL, spaces ) ) != NULL ) {

                // Проверить, является ли данный параметр перенаправлением ввода/вывода
                switch ( parameters[ parameterIndex ][ 0 ] ) {

                    // Если это перенаправление ввода
                    case '<':

                        // Сохранить имя файла исключая символ '<'
                        inputFilename = parameters[ parameterIndex ] + 1;
                        break;

                    // Если это перенаправление вывода
                    case '>':

                        // Сохранить имя файла исключая символ '>'
                        outputFilename = parameters[ parameterIndex ] + 1;
                        break;

                    // Если это не перенаправление (обычный параметр)
                    default:

                        // Увеличить индекс в массиве параметров, чтобы текущий параметр
                        // не был переписан на следующей итерации (как это происходит с
                        // перенаправлениями ввода/вывода)
                        parameterIndex++;
                }
            } // Конец цикла извлечения параметров

            // Создать дочерний процесс для выполнения текущей команды
            if ( fork() == 0 ) {

                // Дочерний процесс

                // Если задано перенаправление ввода
                if ( inputFilename != NULL ) {

                    // Закрыть stdin (дескриптор 0 становится свободным)
                    close( 0 );

                    // Открыть заданный файл на чтение. При этом занимается
                    // минимальный свободный дескриптор (в данном случае 0),
                    // таким образом stdin связывается с заданным файлом.
                    open( inputFilename, O_RDONLY );
                }

                // Если задано перенаправление вывода
                if ( outputFilename != NULL ) {

                    // Закрыть stdout (дескриптор 1 становится свободным)
                    close( 1 );

                    // Создать/открыть заданный файл на запись. При этом занимается
                    // минимальный свободный дескриптор (в данном случае 1),
                    // таким образом stdout связывается с заданным файлом.
                    open( outputFilename, O_CREAT | O_TRUNC | O_WRONLY, 0666 );
                }

                // Загрузить исполняемый файл команды, передав ему параметры
                execvp( parameters[ 0 ], parameters );

                // До этого места исполнение может дойти, только если не удастся
                // загрузить файл команды (если удасться - образ памяти текущего
                // процесса будет полностью заменен, включая код, и этих строк уже
                // просто не будет в памяти процесса). Считаем, что была задана неверная
                // команда, и выводим соответствующее сообщение.
                fprintf( stderr, "error: unknown command '%s'\n", parameters[ 0 ] );

                // Завершить дочерний прооцесс (со статусом ошибки), иначе будeт исполнен
                // последующий код родительского процесса.
                return 1;
            } // Конец дочернего процесса

            // Продолжение родительского процесса

            // Если это была не последняя команда
            if ( commands[ commandIndex + 1 ] != NULL ) {

                // Закрыть stdin (дескриптор 0 становится свободным)
                close( 0 );

                // Создать копию дескриптора выхода канала (read end).
                // В качестве копии береться минимальный свободный дескриптор
                // (в данном случае 0), таким образом stdin связывается с выходом канала.
                dup( pipeFds[ 0 ] );

                // Закрыть первоначальный дескриптор выхода канала.
                // Иначе канал не достигнет EOF.
                close( pipeFds[ 0 ] );

            // Если это была последняя, но не единственная команда
            } else if ( commandIndex > 0 ) {

                // Восстановить оригинальный stdin
                close( 0 );
                dup( inFd );
            }

        } // Конец цикла команд

        // Дождаться завершения всех дочерних процессов
        while ( wait( NULL ) > 0 );

    } // Конец главного цикла

    // Выйти (со статусом успеха)
    return 0;
}
